<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>cope.arena API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>cope.arena</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import heapq
import random

from .link import Link
from .node import Node
from .packet import Packet


class Arena:

    def __init__(self, filename: str) -&gt; None:
        &#34;&#34;&#34;
        Initialize an arena given a file containing: 
            1. a mapping of node types to their capabilities
            2. nodes of each type (identified by MAC address), and their locations as tuples
            3. rules for which types of nodes are allowed to connect to each other
        &#34;&#34;&#34;
        with open(filename, &#39;r&#39;) as f:
            data = json.load(f)

        data_rules = data[&#39;rules&#39;]
        hierarchies = data[&#39;hierarchies&#39;]
        response_wait_time: int = data[&#39;responseWaitTime&#39;]
        packet_pool_expiration: int = float(&#39;inf&#39;)

        rules = {h: set() for h in hierarchies}
        for t1, t2 in data_rules:
            rules[t1].add(t2)
            rules[t2].add(t1)

        # mapping of hierarchies to list MAC addresses
        self.hierarchy_dict: dict[str, list[str]] = {}

        # mapping of MAC addresses to nodes
        self.node_dict: dict[str, Node] = {}

        for hierarchy in hierarchies:
            transmit_distance = hierarchies[hierarchy][&#39;strength&#39;]
            list_of_macs = []
            all_nodes = hierarchies[hierarchy][&#39;nodes&#39;][0]

            for mac_addr, node_obj in all_nodes.items():
                x = node_obj[&#39;x&#39;]
                y = node_obj[&#39;y&#39;]
                node = Node(mac_addr, x, y, hierarchy,
                            transmit_distance, response_wait_time, packet_pool_expiration)

                for link_class in rules[hierarchy]:
                    # if linked to own class, check against current list of MACs
                    if link_class == hierarchy:
                        for other in list_of_macs:
                            node_other = self.node_dict[other]
                            node.add_link(node_other)
                            node_other.add_link(node)

                    # otherwise, check amongst the already finalized hierarchy classes
                    if link_class not in self.hierarchy_dict:
                        continue
                    for other in self.hierarchy_dict[link_class]:
                        node_other = self.node_dict[other]
                        node.add_link(node_other)
                        node_other.add_link(node)

                list_of_macs.append(mac_addr)

                self.node_dict[mac_addr] = node

            self.hierarchy_dict[hierarchy] = list_of_macs

        self.active_node_list: list[str] = list(self.node_dict.keys())
        self.timestep: int = 0
        # memoize the list of best paths
        self.best_paths: dict[tuple[str, str], list[str]] = {}

    def can_link(self, node1: str, node2: str) -&gt; bool:
        &#34;&#34;&#34;
        Given MAC addresses, test if two nodes can connect to one another.

        This involves checking if they are allowed to connect, as well as if they are close enough together
        that, given their power capabilities, they can reach one another.
        &#34;&#34;&#34;
        return self.node_dict[node1].is_linked(node2) and self.node_dict[node2].is_linked(node1)

    def send_packet(self, src_node: str, dst_node: str, is_two_way: bool = True) -&gt; None:
        &#34;&#34;&#34;
        Initiates a packet send from a source node, to a given a destination node.

        Uses Dijkstra&#39;s to find ideal route from source to destination node.
        &#34;&#34;&#34;
        if src_node == dst_node:
            return
        if (src_node, dst_node) in self.best_paths:
            best_path = self.best_paths[(src_node, dst_node)]
            packet = Packet(is_two_way, best_path)
            self.node_dict[src_node].initiate_send(packet, self.timestep)
            return

        probabilities = {node: 0 for node in self.node_dict.keys()}
        probabilities[src_node] = -1
        predecessors = {node: None for node in self.node_dict.keys()}

        priority_queue = [(-1, src_node)]

        while priority_queue:
            current_prob, current_node = heapq.heappop(priority_queue)
            if current_prob &gt; probabilities[current_node]:
                continue

            if current_node == dst_node:
                break

            node_obj = self.node_dict[current_node]
            for neighbor in node_obj.get_neighbors():
                new_prob = current_prob * node_obj.get_probability(neighbor)
                neighbor_prob = probabilities[neighbor]

                if new_prob &lt; neighbor_prob:
                    probabilities[neighbor] = new_prob
                    predecessors[neighbor] = current_node
                    heapq.heappush(priority_queue, (new_prob, neighbor))

        best_path = []
        current_node = dst_node
        while current_node is not None:
            best_path.insert(0, current_node)
            current_node = predecessors[current_node]

        self.best_paths[(src_node, dst_node)] = best_path
        packet = Packet(is_two_way, best_path)
        self.node_dict[src_node].initiate_send(packet, self.timestep)

    def simulate(self, timesteps: int, end_user_hierarchy_class: str, internet_enabled_hierarchy_class: str, min_stream_size: int = 1, max_stream_size: int = 1, probability_send: float = 0.01) -&gt; dict[str, float]:
        &#34;&#34;&#34;
        Simulates the arena for a given number of timesteps, with nodes from the end_user_hierarchy_class sending packets, and users from the internet_enabled_hierarchy_class will receive packets.

        To simulate data streams, will queue random number of packets between min_stream_size and max_stream_size, and at any timestep the probability that a sender node will enqueue a new message is equal to probability_send.
        &#34;&#34;&#34;
        while self.timestep &lt; timesteps:
            if self.timestep % 1 == 0:
                print(self.timestep)
            # queue messages
            for end_user in self.hierarchy_dict[end_user_hierarchy_class]:
                # randomly pick a supernode to send to
                internet_enabled_node = random.choice(
                    self.hierarchy_dict[internet_enabled_hierarchy_class])

                # with random probability, send a flow
                if random.random() &lt; probability_send:
                    num_packets_in_flow = random.randint(
                        min_stream_size, max_stream_size)
                    for _ in range(num_packets_in_flow):
                        self.send_packet(end_user, internet_enabled_node)

            self.run()

        # while there are still packets in queues
        while any(node.packet_in_queues() for node in self.node_dict.values()):
            self.run()
            if self.timestep % 1 == 0:
                print(self.timestep)

        print(self.timestep)

        # get metrics
        per_node_metrics = {}
        for node_mac, node in self.node_dict.items():
            sent = node.get_sent()
            received = node.get_received()
            coded_packet_history = node.get_coded_packets_history()

            coding_opps = len(
                [entry for entry in coded_packet_history if len(entry[0]) &gt; 1])

            packet_drops, packet_successes = 0, 0
            latencies = []
            for packet_id in sent:
                if packet_id not in received:
                    packet_drops += 1
                else:
                    packet_successes += 1
                    latencies.append(received[packet_id] - sent[packet_id])

            per_node_metrics[node_mac] = {
                &#39;successes&#39;: packet_successes,
                &#39;throughput&#39;: packet_successes / timesteps,
                &#39;drops&#39;: packet_drops,
                &#39;average_latency&#39;: sum(latencies)/len(latencies) if len(latencies) &gt; 0 else float(&#39;inf&#39;),
                &#39;coding_opps_taken&#39;: coding_opps,
                &#39;timesteps&#39;: self.timestep
            }

        return per_node_metrics

    def run(self, override=False) -&gt; None:
        &#34;&#34;&#34;
        Steps the arena for one timestep
        &#34;&#34;&#34;
        sending: list[Node] = []
        nexthops = set()
        ht = set()

        for node in self.active_node_list:
            node_obj = self.node_dict[node]

            if node_obj.get_next_destination() is None:
                # checks if all queues are empty
                node_obj.send_reception_report(self.timestep, override)
                continue

            # check if medium is free by comparing to nodes in sending
            for sender in sending:
                # checks if either one is in range of the other
                if node_obj.in_range(*sender.get_position()):
                    break
                elif sender.in_range(*node_obj.get_position()):
                    break
            else:
                sending.append(node_obj)
                nexthop = node_obj.get_next_destination()
                if nexthop in nexthops:
                    ht.add(nexthop)
                else:
                    nexthops.add(nexthop)

        for ht_node in ht:
            nexthops.remove(ht_node)

        for sender in sending:
            dest = sender.get_next_destination()
            # if dest in ht:
            #     print(&#39;hidden terminal&#39;)
            sender.send_from_queues(
                self.timestep, bool(dest in ht), override)

        for sender in sending:
            self.active_node_list.remove(sender.get_mac())
            self.active_node_list.append(sender.get_mac())

        # this bit tells nodes whether they should create a response packet
        for node in self.active_node_list:
            node_obj = self.node_dict[node]
            node_obj.cleanup(self.timestep)
            node_obj.learn_timestep(self.timestep)

        self.timestep += 1

    def get_nodes(self) -&gt; dict[str, Node]:
        &#34;&#34;&#34;
        Returns a dict mapping MAC addresses to node objects for all nodes in this arena
        &#34;&#34;&#34;
        return {k: v for k, v in self.node_dict.items()}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="cope.arena.Arena"><code class="flex name class">
<span>class <span class="ident">Arena</span></span>
<span>(</span><span>filename: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize an arena given a file containing:
1. a mapping of node types to their capabilities
2. nodes of each type (identified by MAC address), and their locations as tuples
3. rules for which types of nodes are allowed to connect to each other</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Arena:

    def __init__(self, filename: str) -&gt; None:
        &#34;&#34;&#34;
        Initialize an arena given a file containing: 
            1. a mapping of node types to their capabilities
            2. nodes of each type (identified by MAC address), and their locations as tuples
            3. rules for which types of nodes are allowed to connect to each other
        &#34;&#34;&#34;
        with open(filename, &#39;r&#39;) as f:
            data = json.load(f)

        data_rules = data[&#39;rules&#39;]
        hierarchies = data[&#39;hierarchies&#39;]
        response_wait_time: int = data[&#39;responseWaitTime&#39;]
        packet_pool_expiration: int = float(&#39;inf&#39;)

        rules = {h: set() for h in hierarchies}
        for t1, t2 in data_rules:
            rules[t1].add(t2)
            rules[t2].add(t1)

        # mapping of hierarchies to list MAC addresses
        self.hierarchy_dict: dict[str, list[str]] = {}

        # mapping of MAC addresses to nodes
        self.node_dict: dict[str, Node] = {}

        for hierarchy in hierarchies:
            transmit_distance = hierarchies[hierarchy][&#39;strength&#39;]
            list_of_macs = []
            all_nodes = hierarchies[hierarchy][&#39;nodes&#39;][0]

            for mac_addr, node_obj in all_nodes.items():
                x = node_obj[&#39;x&#39;]
                y = node_obj[&#39;y&#39;]
                node = Node(mac_addr, x, y, hierarchy,
                            transmit_distance, response_wait_time, packet_pool_expiration)

                for link_class in rules[hierarchy]:
                    # if linked to own class, check against current list of MACs
                    if link_class == hierarchy:
                        for other in list_of_macs:
                            node_other = self.node_dict[other]
                            node.add_link(node_other)
                            node_other.add_link(node)

                    # otherwise, check amongst the already finalized hierarchy classes
                    if link_class not in self.hierarchy_dict:
                        continue
                    for other in self.hierarchy_dict[link_class]:
                        node_other = self.node_dict[other]
                        node.add_link(node_other)
                        node_other.add_link(node)

                list_of_macs.append(mac_addr)

                self.node_dict[mac_addr] = node

            self.hierarchy_dict[hierarchy] = list_of_macs

        self.active_node_list: list[str] = list(self.node_dict.keys())
        self.timestep: int = 0
        # memoize the list of best paths
        self.best_paths: dict[tuple[str, str], list[str]] = {}

    def can_link(self, node1: str, node2: str) -&gt; bool:
        &#34;&#34;&#34;
        Given MAC addresses, test if two nodes can connect to one another.

        This involves checking if they are allowed to connect, as well as if they are close enough together
        that, given their power capabilities, they can reach one another.
        &#34;&#34;&#34;
        return self.node_dict[node1].is_linked(node2) and self.node_dict[node2].is_linked(node1)

    def send_packet(self, src_node: str, dst_node: str, is_two_way: bool = True) -&gt; None:
        &#34;&#34;&#34;
        Initiates a packet send from a source node, to a given a destination node.

        Uses Dijkstra&#39;s to find ideal route from source to destination node.
        &#34;&#34;&#34;
        if src_node == dst_node:
            return
        if (src_node, dst_node) in self.best_paths:
            best_path = self.best_paths[(src_node, dst_node)]
            packet = Packet(is_two_way, best_path)
            self.node_dict[src_node].initiate_send(packet, self.timestep)
            return

        probabilities = {node: 0 for node in self.node_dict.keys()}
        probabilities[src_node] = -1
        predecessors = {node: None for node in self.node_dict.keys()}

        priority_queue = [(-1, src_node)]

        while priority_queue:
            current_prob, current_node = heapq.heappop(priority_queue)
            if current_prob &gt; probabilities[current_node]:
                continue

            if current_node == dst_node:
                break

            node_obj = self.node_dict[current_node]
            for neighbor in node_obj.get_neighbors():
                new_prob = current_prob * node_obj.get_probability(neighbor)
                neighbor_prob = probabilities[neighbor]

                if new_prob &lt; neighbor_prob:
                    probabilities[neighbor] = new_prob
                    predecessors[neighbor] = current_node
                    heapq.heappush(priority_queue, (new_prob, neighbor))

        best_path = []
        current_node = dst_node
        while current_node is not None:
            best_path.insert(0, current_node)
            current_node = predecessors[current_node]

        self.best_paths[(src_node, dst_node)] = best_path
        packet = Packet(is_two_way, best_path)
        self.node_dict[src_node].initiate_send(packet, self.timestep)

    def simulate(self, timesteps: int, end_user_hierarchy_class: str, internet_enabled_hierarchy_class: str, min_stream_size: int = 1, max_stream_size: int = 1, probability_send: float = 0.01) -&gt; dict[str, float]:
        &#34;&#34;&#34;
        Simulates the arena for a given number of timesteps, with nodes from the end_user_hierarchy_class sending packets, and users from the internet_enabled_hierarchy_class will receive packets.

        To simulate data streams, will queue random number of packets between min_stream_size and max_stream_size, and at any timestep the probability that a sender node will enqueue a new message is equal to probability_send.
        &#34;&#34;&#34;
        while self.timestep &lt; timesteps:
            if self.timestep % 1 == 0:
                print(self.timestep)
            # queue messages
            for end_user in self.hierarchy_dict[end_user_hierarchy_class]:
                # randomly pick a supernode to send to
                internet_enabled_node = random.choice(
                    self.hierarchy_dict[internet_enabled_hierarchy_class])

                # with random probability, send a flow
                if random.random() &lt; probability_send:
                    num_packets_in_flow = random.randint(
                        min_stream_size, max_stream_size)
                    for _ in range(num_packets_in_flow):
                        self.send_packet(end_user, internet_enabled_node)

            self.run()

        # while there are still packets in queues
        while any(node.packet_in_queues() for node in self.node_dict.values()):
            self.run()
            if self.timestep % 1 == 0:
                print(self.timestep)

        print(self.timestep)

        # get metrics
        per_node_metrics = {}
        for node_mac, node in self.node_dict.items():
            sent = node.get_sent()
            received = node.get_received()
            coded_packet_history = node.get_coded_packets_history()

            coding_opps = len(
                [entry for entry in coded_packet_history if len(entry[0]) &gt; 1])

            packet_drops, packet_successes = 0, 0
            latencies = []
            for packet_id in sent:
                if packet_id not in received:
                    packet_drops += 1
                else:
                    packet_successes += 1
                    latencies.append(received[packet_id] - sent[packet_id])

            per_node_metrics[node_mac] = {
                &#39;successes&#39;: packet_successes,
                &#39;throughput&#39;: packet_successes / timesteps,
                &#39;drops&#39;: packet_drops,
                &#39;average_latency&#39;: sum(latencies)/len(latencies) if len(latencies) &gt; 0 else float(&#39;inf&#39;),
                &#39;coding_opps_taken&#39;: coding_opps,
                &#39;timesteps&#39;: self.timestep
            }

        return per_node_metrics

    def run(self, override=False) -&gt; None:
        &#34;&#34;&#34;
        Steps the arena for one timestep
        &#34;&#34;&#34;
        sending: list[Node] = []
        nexthops = set()
        ht = set()

        for node in self.active_node_list:
            node_obj = self.node_dict[node]

            if node_obj.get_next_destination() is None:
                # checks if all queues are empty
                node_obj.send_reception_report(self.timestep, override)
                continue

            # check if medium is free by comparing to nodes in sending
            for sender in sending:
                # checks if either one is in range of the other
                if node_obj.in_range(*sender.get_position()):
                    break
                elif sender.in_range(*node_obj.get_position()):
                    break
            else:
                sending.append(node_obj)
                nexthop = node_obj.get_next_destination()
                if nexthop in nexthops:
                    ht.add(nexthop)
                else:
                    nexthops.add(nexthop)

        for ht_node in ht:
            nexthops.remove(ht_node)

        for sender in sending:
            dest = sender.get_next_destination()
            # if dest in ht:
            #     print(&#39;hidden terminal&#39;)
            sender.send_from_queues(
                self.timestep, bool(dest in ht), override)

        for sender in sending:
            self.active_node_list.remove(sender.get_mac())
            self.active_node_list.append(sender.get_mac())

        # this bit tells nodes whether they should create a response packet
        for node in self.active_node_list:
            node_obj = self.node_dict[node]
            node_obj.cleanup(self.timestep)
            node_obj.learn_timestep(self.timestep)

        self.timestep += 1

    def get_nodes(self) -&gt; dict[str, Node]:
        &#34;&#34;&#34;
        Returns a dict mapping MAC addresses to node objects for all nodes in this arena
        &#34;&#34;&#34;
        return {k: v for k, v in self.node_dict.items()}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="cope.arena.Arena.can_link"><code class="name flex">
<span>def <span class="ident">can_link</span></span>(<span>self, node1: str, node2: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Given MAC addresses, test if two nodes can connect to one another.</p>
<p>This involves checking if they are allowed to connect, as well as if they are close enough together
that, given their power capabilities, they can reach one another.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def can_link(self, node1: str, node2: str) -&gt; bool:
    &#34;&#34;&#34;
    Given MAC addresses, test if two nodes can connect to one another.

    This involves checking if they are allowed to connect, as well as if they are close enough together
    that, given their power capabilities, they can reach one another.
    &#34;&#34;&#34;
    return self.node_dict[node1].is_linked(node2) and self.node_dict[node2].is_linked(node1)</code></pre>
</details>
</dd>
<dt id="cope.arena.Arena.get_nodes"><code class="name flex">
<span>def <span class="ident">get_nodes</span></span>(<span>self) ‑> dict[str, <a title="cope.node.Node" href="node.html#cope.node.Node">Node</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a dict mapping MAC addresses to node objects for all nodes in this arena</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_nodes(self) -&gt; dict[str, Node]:
    &#34;&#34;&#34;
    Returns a dict mapping MAC addresses to node objects for all nodes in this arena
    &#34;&#34;&#34;
    return {k: v for k, v in self.node_dict.items()}</code></pre>
</details>
</dd>
<dt id="cope.arena.Arena.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, override=False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Steps the arena for one timestep</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, override=False) -&gt; None:
    &#34;&#34;&#34;
    Steps the arena for one timestep
    &#34;&#34;&#34;
    sending: list[Node] = []
    nexthops = set()
    ht = set()

    for node in self.active_node_list:
        node_obj = self.node_dict[node]

        if node_obj.get_next_destination() is None:
            # checks if all queues are empty
            node_obj.send_reception_report(self.timestep, override)
            continue

        # check if medium is free by comparing to nodes in sending
        for sender in sending:
            # checks if either one is in range of the other
            if node_obj.in_range(*sender.get_position()):
                break
            elif sender.in_range(*node_obj.get_position()):
                break
        else:
            sending.append(node_obj)
            nexthop = node_obj.get_next_destination()
            if nexthop in nexthops:
                ht.add(nexthop)
            else:
                nexthops.add(nexthop)

    for ht_node in ht:
        nexthops.remove(ht_node)

    for sender in sending:
        dest = sender.get_next_destination()
        # if dest in ht:
        #     print(&#39;hidden terminal&#39;)
        sender.send_from_queues(
            self.timestep, bool(dest in ht), override)

    for sender in sending:
        self.active_node_list.remove(sender.get_mac())
        self.active_node_list.append(sender.get_mac())

    # this bit tells nodes whether they should create a response packet
    for node in self.active_node_list:
        node_obj = self.node_dict[node]
        node_obj.cleanup(self.timestep)
        node_obj.learn_timestep(self.timestep)

    self.timestep += 1</code></pre>
</details>
</dd>
<dt id="cope.arena.Arena.send_packet"><code class="name flex">
<span>def <span class="ident">send_packet</span></span>(<span>self, src_node: str, dst_node: str, is_two_way: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Initiates a packet send from a source node, to a given a destination node.</p>
<p>Uses Dijkstra's to find ideal route from source to destination node.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_packet(self, src_node: str, dst_node: str, is_two_way: bool = True) -&gt; None:
    &#34;&#34;&#34;
    Initiates a packet send from a source node, to a given a destination node.

    Uses Dijkstra&#39;s to find ideal route from source to destination node.
    &#34;&#34;&#34;
    if src_node == dst_node:
        return
    if (src_node, dst_node) in self.best_paths:
        best_path = self.best_paths[(src_node, dst_node)]
        packet = Packet(is_two_way, best_path)
        self.node_dict[src_node].initiate_send(packet, self.timestep)
        return

    probabilities = {node: 0 for node in self.node_dict.keys()}
    probabilities[src_node] = -1
    predecessors = {node: None for node in self.node_dict.keys()}

    priority_queue = [(-1, src_node)]

    while priority_queue:
        current_prob, current_node = heapq.heappop(priority_queue)
        if current_prob &gt; probabilities[current_node]:
            continue

        if current_node == dst_node:
            break

        node_obj = self.node_dict[current_node]
        for neighbor in node_obj.get_neighbors():
            new_prob = current_prob * node_obj.get_probability(neighbor)
            neighbor_prob = probabilities[neighbor]

            if new_prob &lt; neighbor_prob:
                probabilities[neighbor] = new_prob
                predecessors[neighbor] = current_node
                heapq.heappush(priority_queue, (new_prob, neighbor))

    best_path = []
    current_node = dst_node
    while current_node is not None:
        best_path.insert(0, current_node)
        current_node = predecessors[current_node]

    self.best_paths[(src_node, dst_node)] = best_path
    packet = Packet(is_two_way, best_path)
    self.node_dict[src_node].initiate_send(packet, self.timestep)</code></pre>
</details>
</dd>
<dt id="cope.arena.Arena.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self, timesteps: int, end_user_hierarchy_class: str, internet_enabled_hierarchy_class: str, min_stream_size: int = 1, max_stream_size: int = 1, probability_send: float = 0.01) ‑> dict[str, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Simulates the arena for a given number of timesteps, with nodes from the end_user_hierarchy_class sending packets, and users from the internet_enabled_hierarchy_class will receive packets.</p>
<p>To simulate data streams, will queue random number of packets between min_stream_size and max_stream_size, and at any timestep the probability that a sender node will enqueue a new message is equal to probability_send.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(self, timesteps: int, end_user_hierarchy_class: str, internet_enabled_hierarchy_class: str, min_stream_size: int = 1, max_stream_size: int = 1, probability_send: float = 0.01) -&gt; dict[str, float]:
    &#34;&#34;&#34;
    Simulates the arena for a given number of timesteps, with nodes from the end_user_hierarchy_class sending packets, and users from the internet_enabled_hierarchy_class will receive packets.

    To simulate data streams, will queue random number of packets between min_stream_size and max_stream_size, and at any timestep the probability that a sender node will enqueue a new message is equal to probability_send.
    &#34;&#34;&#34;
    while self.timestep &lt; timesteps:
        if self.timestep % 1 == 0:
            print(self.timestep)
        # queue messages
        for end_user in self.hierarchy_dict[end_user_hierarchy_class]:
            # randomly pick a supernode to send to
            internet_enabled_node = random.choice(
                self.hierarchy_dict[internet_enabled_hierarchy_class])

            # with random probability, send a flow
            if random.random() &lt; probability_send:
                num_packets_in_flow = random.randint(
                    min_stream_size, max_stream_size)
                for _ in range(num_packets_in_flow):
                    self.send_packet(end_user, internet_enabled_node)

        self.run()

    # while there are still packets in queues
    while any(node.packet_in_queues() for node in self.node_dict.values()):
        self.run()
        if self.timestep % 1 == 0:
            print(self.timestep)

    print(self.timestep)

    # get metrics
    per_node_metrics = {}
    for node_mac, node in self.node_dict.items():
        sent = node.get_sent()
        received = node.get_received()
        coded_packet_history = node.get_coded_packets_history()

        coding_opps = len(
            [entry for entry in coded_packet_history if len(entry[0]) &gt; 1])

        packet_drops, packet_successes = 0, 0
        latencies = []
        for packet_id in sent:
            if packet_id not in received:
                packet_drops += 1
            else:
                packet_successes += 1
                latencies.append(received[packet_id] - sent[packet_id])

        per_node_metrics[node_mac] = {
            &#39;successes&#39;: packet_successes,
            &#39;throughput&#39;: packet_successes / timesteps,
            &#39;drops&#39;: packet_drops,
            &#39;average_latency&#39;: sum(latencies)/len(latencies) if len(latencies) &gt; 0 else float(&#39;inf&#39;),
            &#39;coding_opps_taken&#39;: coding_opps,
            &#39;timesteps&#39;: self.timestep
        }

    return per_node_metrics</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="cope" href="index.html">cope</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="cope.arena.Arena" href="#cope.arena.Arena">Arena</a></code></h4>
<ul class="">
<li><code><a title="cope.arena.Arena.can_link" href="#cope.arena.Arena.can_link">can_link</a></code></li>
<li><code><a title="cope.arena.Arena.get_nodes" href="#cope.arena.Arena.get_nodes">get_nodes</a></code></li>
<li><code><a title="cope.arena.Arena.run" href="#cope.arena.Arena.run">run</a></code></li>
<li><code><a title="cope.arena.Arena.send_packet" href="#cope.arena.Arena.send_packet">send_packet</a></code></li>
<li><code><a title="cope.arena.Arena.simulate" href="#cope.arena.Arena.simulate">simulate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>